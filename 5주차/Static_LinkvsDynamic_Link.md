# Static Link vs. Dynamic Link

---

## ****라이브러리 📚****

라이브러리는 컴퓨터 시스템에서, 프로그램들이 함수나, 변수를 공유해서 사용할 수 있게 합니다.

대표적으로, C의 표준 라이브러리인 `libc`는 우분투에 기본으로 탑재된 라이브러리이며, 실습환경에서는 `/lib/x86_64-linux-gnu/libc-2.27.so`에 있습니다. 처음 코딩을 공부할 때, `printf`를 정의한 적이 없지만 `printf(“Hello, World!”)`라는 예제를 컴파일해서, 실행할 수 있는 것은 `libc`에 이 함수가 이미 정의되어 있기 때문입니다.

---

## ****링크🖇️****

**링크(Link)**는 많은 프로그래밍 언어에서 컴파일의 마지막 단계로 알려져 있습니다. 프로그램에서 어떤 라이브러리의 함수를 사용한다면, 호출된 함수와 실제 라이브러리의 함수가 링크 과정에서 연결됩니다.

---

## ****라이브러리와 링크의 종류****🧮

라이브러리는 크게 동적 라이브러리와 정적 라이브러리로 구분되며, 동적 라이브러리를 링크하는 것을 **동적 링크(Dynamic Link),** 정적 라이브러리를 링크하는 것을 **정적 링크(Static Link)**라고 부릅니다.

### ****동적 링크****

> 동적 링크된 바이너리를 실행하면 동적 라이브러리가 프로세스의 메모리에 매핑됩니다. 그리고 실행 중에 라이브러리의 함수를 호출하면 매핑된 라이브러리에서 호출할 함수의 주소를 찾고, 그 함수를 실행합니다.
> 

### ****정적 링크****

> 정적 링크를 하면 바이너리에 정적 라이브러리의 필요한 모든 함수가 포함됩니다. 따라서 해당 함수를 호출할 때, 라이브러리를 참조하는 것이 아니라, 자신의 함수를 호출하는 것처럼 호출할 수 있습니다.
> 

---

## **PLT와 GOT**

**PLT(Procedure Linkage Table)**와 **GOT(Global Offset Table)**는 라이브러리에서 동적 링크된 심볼의 주소를 찾을 때 사용하는 테이블입니다.

바이너리가 실행되면 ASLR에 의해 라이브러리가 임의의 주소에 매핑됩니다. 이 상태에서 라이브러리 함수를 호출하면, 함수의 이름을 바탕으로 라이브러리에서 심볼들을 탐색하고, 해당 함수의 정의를 발견하면 그 주소로 실행 흐름을 옮기게 됩니다. 이 과정을 통틀어 runtime resolve 라고한다.

그런데 만약 반복적으로 호출되는 함수의 정의를 매번 탐색해야 한다면 비효율적일 것입니다. 그래서 ELF는 GOT라는 테이블을 두고, *resolve*된 함수의 주소를 해당 테이블에 저장합니다. 그리고 나중에 다시 해당 함수를 호출하면 저장된 주소를 꺼내서 사용합니다.

---

## ****시스템 해킹의 관점에서 본 PLT와 GOT****

시스템 해커의 관점에서 보면 PLT에서 GOT를 참조하여 실행 흐름을 옮길 때, GOT의 값을 검증하지 않는다는 보안상의 약점이 있습니다.따라서 앞의 예에서 GOT에 저장된 `puts`의 주소를 공격자가 임의로 변경할 수 있으면, 두 번째로 `puts`가 호출될 때 공격자가 원하는 코드가 실행되게할 수 있습니다.

이런 공격 기법을 **GOT Overwrite**라고 부르며, 임의 주소에 값을 쓸 수 있을 때, RCE를 하기 위한 방법으로 사용될 수 있습니다.